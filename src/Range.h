/*
 * Range.h
 *
 *  Created on: 7 Nov 2012
 *      Author: jmp84. Adapted from Gonzalo Iglesias.
 */

#ifndef RANGE_H_
#define RANGE_H_

#include <boost/algorithm/string.hpp>
#include <glog/logging.h>
#include <fst/compat.h>

/**
 * \brief Generates ranges  from a compact string parameter such as 1,3:5,10
 * \param range A key string such as 1,3:5,10, describing a range of values.
 * \param x A vector containing explicitly the integers we care about
 */

namespace cam {
namespace eng {
namespace gen {

/**
 * Generates ranges from a compact string parameter such as 1,3:5,10
 * @param range A key string such as 1,3:5,10, describing a range of values.
 * @param res A vector containing explicitly the integers we care about.
 */
inline void getRange(const std::string& range, std::vector<int>* res) {
  std::vector<std::string> aux;
  boost::split(aux, range, boost::is_any_of(","));
  for (int i = 0; i < aux.size(); ++i) {
    std::string& part = aux[i];
    if (part.find(":") == std::string::npos) {
      res->push_back(boost::lexical_cast<int>(aux[i]));
      continue;
    }
    std::vector<std::string> rangeAux;
    boost::split(rangeAux, part, boost::is_any_of(":"));
    CHECK_LE(rangeAux.size(), 3) << "Range incorrectly defined: " << range;
    int jump = 1;
    if (rangeAux.size() == 3) {
      jump = boost::lexical_cast<int>(rangeAux[1]);
    }
    int start = boost::lexical_cast<int>(rangeAux[0]);
    int end = boost::lexical_cast<int>(rangeAux[rangeAux.size() - 1]);
    for (int k = start; k <= end; k += jump) {
      res->push_back(k);
    }
  }
};

/**
 * Interface for an arbitrary range of integers.
 */
class IntegerRangeInterface {
public:
  virtual void next ( void ) = 0;
  virtual bool done ( void ) = 0;
  virtual void start ( void ) = 0;
  virtual int get ( void ) = 0;

  virtual ~IntegerRangeInterface() {};

  static IntegerRangeInterface* initFactory(const std::string&);
};

/**
 * Implements an Integer Range iterator in a vector<int> generated by getRange
 * function.
 */
class IntegerRange : public IntegerRangeInterface {
private:
  /** Arbitrary sequence of integers. */
  std::vector<int> range_;
  /** Current position. */
  int k_;

public:
  /**
   * Constructor.
   * @param r Vector of integers.
   */
  IntegerRange (const std::vector<int>& r) : range_(r), k_(0) {};

  /**
   * Constructor.
   * @param
   */
  IntegerRange(const std::string& flag) : k_ (0) {
    getRange(flag, &range_);
  };

  /** Empty implementation. */
  inline void start (void) {};
  /** Increment index. */
  inline void next (void) {if (!done()) ++k_;};
  /** Checks if reached the last element. */
  inline bool done (void) {return k_ >= range_.size();};
  /** Returns range value at position k_. */
  inline int get (void) {return range_.at(k_);};

private:
  DISALLOW_COPY_AND_ASSIGN ( IntegerRange );
};

IntegerRangeInterface* IntegerRangeInterface::initFactory(
    const std::string& flag) {
  return new IntegerRange(flag);
};

} // namespace gen
} // namespace eng
} // namespace cam

#endif /* RANGE_H_ */
